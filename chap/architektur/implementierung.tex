\section{Implementierung}

Im folgendem wird auf die Implementierungsdetails der einzelnen Komponenten eingegangen. Hierbei wird der grundlegende Aufbau der Komponenten erklärt.
Zudem wird auf einige Optimierungen und Designentscheidungen eingegangen.


\subsection{Model}



Um Multilayer Graphen in GE abzubilden wird pro Knoten und Layer eine Zelle erstellt. Die Zellen speichern hierbei ihre ID ihren Layer, eine Liste der ausgehenden Kanten und Daten die für die ALgorithmen notwendig sind.
Die Kanten müssen dabei speichern auf welche ID in welchem Layer sie zeigen.

\begin{lstlisting}{language=c,label={lst:tslModel}}
struct Edge {
  long StartId;
  int StartLayer;
  long DestinationId;
  int DestinationLayer;
  float Weight;
}

// We create a cell for each layer a node is on
cell struct Node {
  long Id;
  int Layer;
  PageRankData PageRankData;
  HITSData HITSData;
  DegreeData DegreeData;
  List<Edge> Edges;
}
\end{lstlisting}

Die Proxy wird mit allen unterstützen Protokollen definiert. 

Die Proxy muss von den Servern benachrichtigt werden können wenn diese asynchrone Aufgaben erfüllt haben. Dabei kann auch ein Ergebnis zurückgegeben werden.
Dafür wird ein 'PhaseFinished' Protokoll erstellt. Die Server nutzen das Protokoll um der Proxy eine PhaseFinishedMessage zu senden. Diese Nachricht enthält
die Phase die beendet wurde und eine Liste an Strings welche das Ergebniss der jeweiligen Phase darstellt. Es wird hier aus zwei Gründen eine Liste an Strings verwendet. Zum einem gibt es Algorithmen die ein Ergebniss pro Layer des Graphen zurückgegeben wollen. Dabei stellt jedes Element der Liste einen Layer des Graphen dar. Zum anderen werden Strings verwendet da die Ergbenisse verschiedenen Datentypen haben können welche allerdings alle in einem String dargestellt werden können. So gibt ein Algorithmus der Knoten zählt nur Integer Werte zurück während einer der PageRank Werte zurückgiebt Double werte benutzt.
Die Phasen werden in einer seperaten TSL Datei verwaltet und als Enum abgespeichert.

Um von der Proxy Ergebnisse zurück an den Client geben zu können gibt es das Konstrukt 'AlgorithmResult'. Dieses beinhaltet sowohl ein Ergebnis in Tabellenform als auch die Laufzeit des Algorithmusses.


\begin{lstlisting}{language=c}

struct AlgorithmResult {
  string Name;
  DateTime StartTime;
  DateTime EndTime;
  List<List<string>> ResultTable;
}

struct StandardAlgorithmMessage {
  AlgorithmOptions AlgorithmOptions;
  OutputOptions OutputOptions;
}

struct PhaseFinishedMessage {
  List<string> Result;
  Phases Phase;
}

protocol PhaseFinished {
  Type: Asyn;
  Request: PhaseFinishedMessage;
  Response: void;
}

proxy MultiLayerProxy {
  // Base Protocols
  protocol PhaseFinished;
  // Data Load Protocols
  protocol LoadGraphProxy;
  ...
  // EgoNetwork
  protocol EgoNetworkProxy
}
\end{lstlisting}


\begin{lstlisting}
// This is a list of all the phases for the different algorithms
// These will be used in the proxies PhaseFinished protocol to identify
// which phase has been finished.
enum Phases {
  // DataLoad Phases
  DataLoad = 0,
  // Stats Phases
  NodeCount = 1,
  EdgeCount = 2,
  ...
  // EgoNetwork
  EgoNetwork = 17
}
\end{lstlisting}


Die einzelnen Algorithmen definieren ihre benötigen Protokolle und Nachrichten in eigenen Dateien. Diese sind jeweils auf den jeweiligen Algorithmus zugeschnitten.
Die Server Definition zieht alle diese Protokolle zusammen, sodass die entsprechenden abstrakten Methoden in der Serverklasse generiert werden.

\subsection{Lib}


Stellt eine statische Klasse 'Graph' zur Verfügung die von den anderen Komponenten genutzt wird. Die Klasse ermöglicht es mit dem in GE gespeicherten Graph zu interagieren ohne die Implementierungsdetails zu kenne. So kann auf Knoten zugregriffen werden wenn nur die ID und Layer bekannt sind ohne wissen zu müssen wie man diese in eine GE ZellenID übersetzt.


\subsubsection{Ausgabe}

Die Bibliothenk stellt die Funktionalität zur Ausgabe von Ergebnissen zur Verfügung. Die verschiedenen Arten Ergebnisse auszugeben implementieren alle
das Interface 'IOutputWriter' weclhes die Funktion 'void WriteOutput(AlgorithmResult algorithmResult)' hat. Es gibt drei verschiedene Ausgabearten:

\begin{itemize}
  \item None, gibt nichts aus
  \item Console, gibt das Ergbniss in der Konsole aus
  \item CSV, gibt das Ergebniss in einer .csv Datei aus
\end{itemize}


\subsection{Client}

Der Client kann über die Kommandozeile gestartet und bedient werden. Entweder mit dem Argument 'interactive' um eine interaktive Sitzung zu starten
in der der Nutzer Befehle eingeben kann die die Proxy dann ausführt. Oder im 'batch' Modus, wo zudem eine Datei mitgegeben werden muss die Anweisungen erhält.

\subsubsection{Kommandos}

Die einzelnen Funktionen des Clients sind in Kommandos aufgeteilt.
Diese implementieren alle das Interface 'ICommand'. Der Client verwaltet ein Dictionary mit allen ICommands die er kennt.
Das Interface bietet Zugang zu Informationen über das Kommando, wie z.B. das Keyword um es aufzurufen oder welche Argumente das Kommando braucht.
Dazu gibt es drei Interface Funktionen:

\begin{itemize}
  \item VerifyArguments(string[] arguments), prüft ob die Liste der Argumente die der Nutzer dem Kommando gegeben hat legitime Argumente für das Kommando sind.
  \item ApplyArguments(string[] arguments), wendet die Argumente auf das Kommando an sodass wenn es danach ausgeführt wird die Werte benutzt.
  \item Run(), führt das jeweilige Kommando aus.
\end{itemize}

Das die Methoden die nur Informationen zurückgegeben sowie das Verfifizieren der Argumente für alle Kommandos gleich funktioniert gibt es eine abstrakte Klasse
'Command' welche diese bereits implementiert. Die Kommandos erben von dieser Klasse und müssen nur noch ApplyArguments(string[] arguments) und Run() selbst implementieren.
Die Kommandos füllen die Informationen über sich selbst jeweils in ihrem Konstruktor aus. Diese sind:

\begin{itemize}
  \item Name, der Name des Kommandos.
  \item Keyword, das Keyword um es aufzurufen
  \item Description, eine kurze Beschriebung was das Kommando macht
  \item Arguments, eine Liste welche die festhält welche Datentypen die Argumente haben
  \item ArgumentsDescription, eine Beschreibung für die einezelnen Argumente
\end{itemize}

\begin{lstlisting}[language=c]
public ShowNode (): base (null) {
  Name = "Show Node";
  Keyword = "showNode";
  Description = "Shows information about a single node";
  Arguments = new string[] {"long", "int"};
  ArgumentsDescription = new string[] {"Id", "Layer"};
}
\end{lstlisting}


Die Verfifizierung der Argumente findet in zwei Schritten statt. Erst wird die Anzahl der gegeben Argumente mit der Anzahl der Elemente von 'Arguments' verglichen.
Im zweiten Schritt wird für jeden Eintrag in 'Arguments' geprüft ob das gegeben Argument dem jeweiligen Type enstpricht.





\subsubsection{Interaktiver Modus}

Der Batch Modus wird mit dem Argument 'interactive' gestartet. Sobald der Client die Verbindung zum GE Cluster aufgebaut hat kann der Nutzer Kommandos eingeben.


\begin{lstlisting}[language=bash]
  $ dotnet run interactive
\end{lstlisting}


\subsubsection{Batch Modus}
 Der Batch Modus wird mit dem Argument 'batch' gestartet. Es muss zudem ein weiteres Argument gegeben werden welches der Pfad zu der batch Datei ist.
 Diese Datei ist eine normale Textdatei welche pro Zeile ein Kommando enthält. Der Client arbeitet die Datei Zeile für Zeile ab und führt die Kommandos aus.
 Die Verarbeitung ist genau die gleich als hätte ein Nutzer das Kommando im interaktiven Modus eingegeben. Wird das Ende der Datei errreicht wird das Client Programm beendet.

\begin{lstlisting}[language=bash]
  $ dotnet run batch path\to\batch\file 
\end{lstlisting}


\subsection{Proxy}



Die in den TSL Dateien definierte Proxy 'MultiLayerProxy' wird vom TSL Compiler in eine abstrakte Klasse 'MultiLayerProxyBase' mit abstrakten Request Handlern compiliert. Diese wird hier von 'MultiLayerProxyImpl' implementiert.
Da die 'MultiLayerProxyImpl' alle Request für alle Protokolle handhaben muss wird sie über mehrere Dateien als partielle Klasse implementiert. Dies ermöglicht die sonst sehr groß werdende Klasse in kleine Teile aufzuteilen sodass eine Datei jeweils nur für einen Algorithmus verantwortlich ist.

\subsubsection{BaseProxy}

In 'MultiLayerBaseProxy.cs' wird grundlegende Funktionalität der Proxy definiert die nicht zu einem einzelnem Algorithmus gehört. Dies ist zum einem die Möglichkeit Algorithmen zu starten und deren Ergebnisse auszugeben zum anderem wird hier die Möglichkeit geboten auf Antworten der einzelnen Servern, sobald diese eine Phase beendet haben, zu warten.
Hat ein Server eine Phase beendet sendet er an die Proxy einen 'PhaseFinished' Request, der die Phase enthält die er beendet hat und wenn nötig sein lokales Ergebnis. Die 'MultiLayerBaseProxy' handhabt diesen Request und zählt wieviele Server eine jeweilige Phase schon beendet haben und sammelt deren Ergbenisse. Hierfür werden drei Elemente verwendet:

\begin{itemize}
  \item Dictionary<Phases, int> phaseFinishedCount, um zu zählen wieviele Server bereits eine bestimmte Phase abgeschlossen haben.
  \item List<List<string>> phaseResults, um die Ergebnisse der einzelnen Server zu aggregieren
  \item object phaseFinishedCountLock, dient als Lock um die Operationen an den anderen beiden Variablen zu schützen
\end{itemize}


Um nun auf eine Phase zu warten wird solange gewartet bis die Anzahl der Server die eine Phase als beendet gemeldet haben der Anzahl aller Server enstpricht.

\begin{lstlisting}[language=c]
public override void PhaseFinishedHandler(PhaseFinishedMessageReader request) {
  // Lock the phaseFinishedCount to avoid lost updates.
  lock (phaseFinishedCountLock) {
    phaseResults.Add(request.Result);
    phaseFinishedCount[request.Phase]++;
  }
}

private void WaitForPhaseAnswers(Phases phase) {
  SpinWait wait = new SpinWait();

  while (phaseFinishedCount[phase] != Global.ServerCount) {
    wait.SpinOnce();
  }

  lock (phaseFinishedCountLock) {
    phaseFinishedCount[phase] = 0;
  }
}
\end{lstlisting}

Die Proxy stellt den einzelnen Algorithmen damit die Möglichkeit auf Ergebnisse zu warten. Außerdem gibt es meherere Methoden die es erlauben die Ergbenisse direkt im gewünschten Datentyp zu erhalten.

\subsubsection{Algorithmen}



\subsection{Server}

Wie schon bei der Proxy wird der in TSL definierte Server 'MultiLayerServer' zu der abstrakten Klasse 'MultiLayerServerBase' kompiliert. Diese hat abstrakte Methoden für die Protokollhandler.
Die MultiLayerServerBase wird von der Klasse 'MultiLayerServerImpl' implementiert, welche auch wieder zur besseren Übersicht in einzelne partielle Klassen aufgeteilt wird. Diese partiellen Teile sind in die jeweiligen Algorithmen und eine Basisklasse 'MultiLayerBaserServer' aufgeteilt.
Der 'MultiLayerBaserServer' bietet den Algorithmen Methoden um der Proxy mitzuteilen das sie eine Phase beendet haben.


\subsubsection{Laden}

Das Laden des Graphen findet verteilt über alle vorhandenen Server statt. Die Kanten werden von einer Kantendatei geladen die je eine Kante pro Zeile speichert. Das genaue Format wie eine Kante in dieser Kantendatei vorhanden ist kann verschieden sein. Wichtig ist das jede Kante die Informationen enthält von welchem Knoten und Layer zu welchem Knoten und Layer sie zeigt.

Jeder Server geht die Kantendatei Zeile für Zeile durch und puffert diese in einer Liste. Die Liste wird solange gefüllt bis der Knoten wechselt von dem die Kanten ausgehen. Sobald der Knoten wechselt wird die gepufferte Liste von Kantenzeilen an einen Threadpool übergeben der die Kantenzeilen lädt und den Knoten in GE speichert.

Um mehrere Formate an Kantenzeilen zu unterstützen gibt es ein Interface 'IEdgeLoader'. Dieses stellt drei Methoden zur verfügung die implementiert werden müssen.

\begin{itemize}
  \item Edge LoadEdge(string line), lädt eine Kante aus einer Zeile \ref{lst:tslModel}
  \item long GetId(string line), list die Knoten ID aus einer Zeile aus
  \item int GetLayer(string line), liest den Layer aus einer Zeile aus
\end{itemize}

Die Methoden GetId und GetLayer sind nötig damit während des pufferns der Zeile festgestellt werden kann sobald der Ursprungsknoten der Kanten wechselt.
Für alle Formate die unterstützt werden sollen muss nun eine Klasse erstellt werden die das Interface implementiert.



\subsection{Erweiterbarkeit}

Das System ist um weitere Funktionen erweiterbar. In diesem Abschnitt wird erläutert welche Schritte notwendig sind um neue Funktionalität hinzuzufügen.
Dabei muss die gewünschte Funktionalität im Model, Client, Proxy und Server hinzugefügt werden.

Um den Ablauf zu veranschaulichen wird dies für eine Beispielfunktion erklärt. Diese zählt die Anzahl an Knoten die eine vom Client bestimmte Anzahl an ausgehenden Kanten besitzt.

\subsubsection{Model}

Im Model muss eine .tsl Datein für den neuen Algorithmus erstellt werden. In dieser werden die Daten und Protokolle die GE unterstützen muss beschrieben. Im Fall der Beispielfunktion sind zwei Protokolle notwendig.
Eines damit der Client die Anfrage für die Ausfürung an die Proxy senden kann und ein weiteres damit die Proxy die einzelnen Server nach ihrer Anzahl an Knoten mit der gewünschten Menge an Kanten fragen kann.
Dabei müssen bei beiden Protokollen die Anzahl der Kanten mitgegeben werden können.

In der Anfrage an die Proxy sollen zudem die Optionen für die Ausfürung von Algorithmen sowie die Option für die Ausgabe von Ergebnissen dabei sein.

\begin{lstlisting}{language=c}
// Proxy Protocol
struct GetNEdgeNodesProxyMessage {
  AlgorithmOptions AlgorithmOptions;
  OutputOptions OutputOptions;
  int NumberOfEdges;  
}

protocol GetNEdgeNodesProxy {
  Type: Syn;
  Request: GetNEdgeNodesProxyMessage;
  Response: void;
}

// Server Protocol
struct GetNEdgeNodesServerMessage {
  int NumberOfEdges;
}

protocol GetNEdgeNodesServer {
  Type: Syn;
  Request: GetNEdgeNodesServerMessage;
  Response: void;
}
\end{lstlisting}

Diese Protokolle müssen nun in 'MultiLayerProxy' und 'MultiLayerServer' eingetragen werden damit die von TSL erzeugte Server/Proxy Basisklasse abstrakte Methoden für diese besitzen.

Damit die Server der Proxy ihre lokalen Ergebnisse zusenden können muss die 'Phases.tsl' Datei um eine Phase für diesen Algoritmus erweitert werden.

\begin{lstlisting}{language=c}
enum Phases {
  // DataLoad Phases
  DataLoad = 0,
  ...
  NEdgesCount = 18
}
\end{lstlisting}


\subsubsection{Client}

Für den neuen Algorithmus muss im Client ein Kommando hinzugefügt werden um diesen auszuführen. Das Kommando muss dabei die Anzahl der Kanten als Argument nehmen und das zuvor definierte Protokoll nutzen um die Anfrage an die Proxy zu senden.

Es wird eine neue Klasse 'NEdgesNodeCount' erstellt welche von der abstrakten Klasse 'Command' erbt. Im Konstruktor müssen nun die bereit in [verweis auf implementuerung der kommands] erwähten Daten eingegeben werden. Dabei ist wichtig das es ein Argument des Typs 'int' gibt welches die Anzahl der gewünschten Kanten darstellt.
Nun müssen die MEthoden 'ApplyArguments' und 'Run' implementiert werden.
In 'ApplyArguments' wird das übergeben Argument in einer lokalen Variable gespeichert sodass es beim Aufruf von 'Run' verwendet werden kann.
In 'Run' wird die im Model bereits definierte Nachricht erstellt und an die Proxy gesendet.

\begin{lstlisting}{language=c}
using MultiLayerLib;
using MultiLayerLib.MultiLayerProxy;

namespace MultiLayerClient.Commands {

  class NEdgesNodeCount: Command {

    private int NumberOfEdges { get; set; }

    public NEdgesNodeCount (Client client): base (client) {
      Name = "NEdge Node Count";
      Keyword = "nEdgeNodeCount";
      Description = "Counts the number of nodes that have a certain amount of edges.";
      Arguments = new string[] { "int" };
      ArgumentsDescription = new string[] { "NumberOfEdges" };
    }

    public override void ApplyArguments(string[] arguments) {
      NumberOfEdges = int.Parse(arguments[0]);
    }

    public override void Run() {
      using (var msg = new GetNEdgeNodesProxyMessageWriter(Client.AlgorithmOptions, Client.OutputOptions, NumberOfEdges)) {
          MessagePassingExtension.GetNEdgeNodesProxy(Client.Proxy, msg);
      }      
    }
  }
}
\end{lstlisting}


In der 'Client' Klasse muss im Konstruktor nun noch das erstellte Kommando registiert werden.

\subsubsection{Proxy}

Für die Proxy müssen zwei Funktionen implementiert werden. Zum einem der Algorithmus der Anfragen an alle Server sendet ihre Anzahl an lokalen Knoten mit N Kanten zu senden und diese Ergebnisse aggregiert. Zum anderem muss 
für das in TSL defineirte Proxy Protokoll 'GetNEdgeNodesProxy' ein entsprechneder Handler erstellt werden der die Anfrage verarbeitet und den Algorithmus startet.

Der Algoritmus muss die abstrakte Klasse 'Algorithm' implementieren insbesondere die abstrakte Methode 'Run()' und 'AlgorithmResult GetResult(OutputOptions outputOptions)'. In Run() wird die im Model erstellte Anfrage an alle Server gesendet, welche auf diese mit ihrer lokalen Anzahl an Knoten mit der gewünschten Kantenanzahl antworten. Die Proxy
wartet bis alle Server Ergebnisse gesendet haben und zählt diese zu einem Gesamtergebniss zusammen.

Die andere Methode dient dazu die Ergebnisse in einer Tabellenform darzustellen. Dazu wird sich die Anzahl der Knoten pro Layer gemerkt und jeder Layer als eine Reihe in der Tabelle dargestellt. Die erste Spalte ist die ID des Layers während die zweite die Anzahl der Knoten in diesem Layer ist. Es wird eine weitere Zeile mit der Gesamtanzahl der Knoten hinzugefügt.

\begin{lstlisting}{language=c}

public override void Run() {
  foreach(var server in Global.CloudStorage) {
    MessagePassingExtension.GetNEdgeNodesServer(server);
  }

  List<List<long>> phaseResults =  Proxy.WaitForPhaseResultsAsLong(Phases.NEdgesCount);
  long[] nodeCount = new long[phaseResults[0].Count];

  // Sum up the results from all the servers.
  foreach(List<long> result in phaseResults) {
    for (int i = 0; i < result.Count; i++) {
        nodeCount[i] += result[i];
    }
  }
}

public override List<List<string>>  GetResultTable(OutputOptions options) {
  List<List<string>> output = new List<List<string>>();
  long totalNodeCount = 0;

  for (int i = 0; i < nodeCount.Length; i++) {
      List<string> outputRow = ResultHelper.Row("Layer" + (i + 1), nodeCount[i].ToString()); 
      output.Add(outputRow);

      totalNodeCount += nodeCount[i];
  }


  output.Add(ResultHelper.Row("Toal", totalNodeCount.ToString()));

  return output;
}



\end{lstlisting}


Der Request Handler muss Teil der partellen Klasse 'MultiLayerProxyImpl' sein. Dafür kann entweder eine weitere Datei erstellt werden oder eine bereits vorhandene genutzt werden die thematisch zu dem Handler passt.
Da Knotenzählen bereits in 'MultiLayerStatsProxy' implementiert ist wird dort auch der Handler für 'GetNEdgeNodesProxy' hinzugefügt. Dieser muss die Anfrage erhalten, den Algorithmus starten und dann die Ergebnisse ausgeben.

\begin{lstlisting}{language=c}
using MultiLayerProxy.Algorithms;
using MultiLayerLib;

namespace MultiLayerProxy.Proxy {

  partial class MultiLayerProxyImpl: MultiLayerProxyBase {

    public override void GetNEdgeNodesProxyHandler(GetNEdgeNodesProxyMessageReader request) {
      NodeCount nEdgesnodeCount = new NEdgesnodeCount(this, request.NumberOfEdges);

      RunAlgorithm(nEdgesnodeCount, request.AlgorithmOptions);
      OutputAlgorithmResult(nEdgesnodeCount, request.OutputOptions);
    }
  
    // Rest of the class ommitted
  }
}
\end{lstlisting}



\subsubsection{Server}

Auf der Serverseite müssen zwei Funktionen implementiert werden. Der Request im Model definierte Handler 'GetNEdgeNodesServer', welcher von der Proxy aufgerufen wird. Dieser muss die Anfrage verarbeiten und die Funktion zur Berechnung der Kantenanzahl starten. Das Ergebniss dieser Funktion muss wieder zurück an die Proxy gesendet werden.
Dazu muss natürlich die Funktion implementiert werden welche die Kantenanzahl zählt.

Der Request Handler passt auch hier thematisch wieder zu der bereits vorhanden Datei 'MultiLayerStatsServer' der eine parteille Klasse der Server Implementierung ist. So wird der Handler hier hinzugefügt.
Es wird das Parameter 'NumberOfEdges' aus der Anfrage gelesen und der Funktion zu Berechnung übergeben. Da die Ergebnisse als String Liste an die Proxy übergeben werden müssen werden diese zu String konvertiert.


\begin{lstlisting}{language=c}
public override void GetNEdgeNodesServerHandler(GetNEdgeNodesServerMessageReader request) {
  List<long> result = Stats.GetNEdgeNodes(request.NumberOfEdges);

  PhaseFinished(Phases.NEdgesCount, Util.ToStringList(result));
}
\end{lstlisting}

Die Funktion zur Berechnung selbst wird als statische Funktion der bereits vorhanden Klasse 'Stats' realisiert. Gäbe es keine passende Klasse kann diese natürlich nach Bedarf erstellt werden.
In der Funktion selbst wird über alle lokalen Knoten iteriert und die Anzahl der Knoten mit der gewunschten Kantenanzahl pro Layer gezählt. 

Das Ergebniss wird zurück an die Proxy gesendet.

\begin{lstlisting}{language=c}
public static List<long> GetNEdgeNodeCount(int numberOfEdges) {
  long[] nodeCount = new long[Graph.LayerCount];

  foreach(Node_Accessor node in Graph.NodeAccessor()) {
    // Only count nodes with the correct amount of edges
    if (node.Edges.Count == numberOfEdges) {
      nodeCount[node.Layer - 1]++;
    }
  }

  List<long> result = new List<long>(nodeCount);
  return result;
}
\end{lstlisting}




